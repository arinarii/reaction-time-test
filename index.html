<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Reaction Time Test</title>
<style>
  :root {
    --rect-width: 360px;
    --rect-height: 220px;
    --border-radius: 12px;
    --font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body {
    font-family: var(--font-family);
    display: flex;
    min-height: 100vh;
    margin: 0;
    align-items: center;
    justify-content: center;
    background: #f5f6f8;
    color: #111;
  }
  .container {
    width: min(880px, 94%);
    text-align: center;
  }
  h1 { margin: 0 0 12px 0; font-size: 20px; }
  .controls { margin-bottom: 18px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
  button {
    background: #1976d2;
    color: white;
    border: none;
    padding: 10px 14px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
  }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .stat { font-size: 14px; color: #333; }
  .rect-wrap { display:flex; justify-content:center; margin-bottom: 14px; }
  .rect {
    width: var(--rect-width);
    height: var(--rect-height);
    border-radius: var(--border-radius);
    display:flex;
    align-items:center;
    justify-content:center;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
    font-size: 28px;
    font-weight: 700;
    color: white;
    box-shadow: 0 6px 18px rgba(15,20,30,0.08), inset 0 -4px 8px rgba(0,0,0,0.06);
    transition: background 180ms ease;
  }
  .rect.red { background: #8b0000; } /* dark red */
  .rect.green { background: #25a44b; }
  .rect.disabled { background: #bbb; color: #333; box-shadow: none; }
  .messages { margin-top: 8px; min-height: 1.2em; color: #b00020; font-weight: 600; }
  .results { margin-top: 14px; text-align:left; background:#fff; border-radius:10px; padding:12px; box-shadow: 0 6px 18px rgba(15,20,30,0.03); }
  .times { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .time-pill { background:#eef6ff; padding:6px 8px; border-radius:8px; font-weight:600; color:#012a4a; }
  footer { margin-top:12px; font-size:12px; color:#555; text-align:center; }
</style>
</head>
<body>
  <div class="container" role="main">
    <h1>Reaction Time Test — 10 Trials</h1>

    <div class="controls">
      <button id="startBtn">Start Test (10 trials)</button>
      <div class="stat" id="status">Ready</div>
      <div class="stat" id="trialCounter">0 / 10</div>
    </div>

    <div class="rect-wrap">
      <div id="rect" class="rect disabled" aria-live="polite" tabindex="0">Start</div>
    </div>

    <div class="messages" id="message" aria-live="assertive"></div>

    <div class="results" id="results" style="display:none;">
      <div><strong>Results</strong></div>
      <div id="avg" style="margin-top:6px;">Average: —</div>
      <div class="times" id="timesList" aria-live="polite"></div>
      <div style="margin-top:10px;">
        <button id="restartBtn">Restart Test</button>
      </div>
    </div>

    <footer>
      Make sure your pointer (or finger) stays still and inside the red rectangle while it waits.
    </footer>

    <audio id="sound" src="soundEffect.mp3" preload="auto"></audio>
  </div>

<script>
(() => {
  const TRIALS = 10;
  const rect = document.getElementById('rect');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const statusEl = document.getElementById('status');
  const trialCounter = document.getElementById('trialCounter');
  const messageEl = document.getElementById('message');
  const resultsEl = document.getElementById('results');
  const avgEl = document.getElementById('avg');
  const timesList = document.getElementById('timesList');
  const sound = document.getElementById('sound');

  let trialIndex = 0;
  let successfulTimes = [];

  let state = 'idle';  
  let waitTimer = null;
  let timeGreen = 0;
  let activePointerId = null;
  let initialPointerPos = null;
  let pointerInside = false;

  const MOVE_TOLERANCE = 8;

  // New: For letter requirement
  let requiredLetter = null;
  let letterPressed = false;
  let mouseReleased = false;

  function resetVars() {
    clearTimeout(waitTimer);
    waitTimer = null;
    timeGreen = 0;
    activePointerId = null;
    initialPointerPos = null;
    pointerInside = false;

    requiredLetter = null;
    letterPressed = false;
    mouseReleased = false;
  }

  function setStatus(txt) { statusEl.textContent = txt; }
  function setMessage(txt, color = '') {
    messageEl.textContent = txt;
    messageEl.style.color = color || '';
  }
  function updateTrialCounter() {
    trialCounter.textContent = `${trialIndex} / ${TRIALS}`;
  }

  function setRectState(kind, text = '') {
    rect.classList.remove('red','green','disabled');

    if (kind === 'red') {
      rect.classList.add('red');
      rect.textContent = text || 'Hold';
    } else if (kind === 'green') {
      rect.classList.add('green');
      rect.textContent = text;
    } else {
      rect.classList.add('disabled');
      rect.textContent = text || 'Start';
    }
  }

  function randomDelayMs() {
    return Math.floor(1000 + Math.random() * 6000);
  }

  function beginTest() {
    trialIndex = 0;
    successfulTimes = [];
    resultsEl.style.display = 'none';
    startBtn.disabled = true;
    setMessage('');
    updateTrialCounter();
    setStatus('Test started — hold until green');
    nextTrial();
  }

  function finishTest() {
    startBtn.disabled = false;
    setStatus('Test complete');

    resultsEl.style.display = 'block';
    timesList.innerHTML = '';
    successfulTimes.forEach((t,i)=>{
      const pill = document.createElement('div');
      pill.className = 'time-pill';
      pill.textContent = `#${i+1}: ${t.toFixed(0)} ms`;
      timesList.appendChild(pill);
    });

    const avg = successfulTimes.reduce((a,b)=>a+b,0) / successfulTimes.length;
    avgEl.textContent = `Average: ${avg.toFixed(0)} ms (${successfulTimes.length} trials)`;
  }

  function nextTrial() {
    resetVars();

    if (trialIndex >= TRIALS) {
      finishTest();
      return;
    }

    state = 'waitingForHold';
    setRectState('red','Hold');
    setStatus(`Trial ${trialIndex+1} — Hold inside the rectangle`);
    updateTrialCounter();
    setMessage('Hold and keep still.');
  }

  // --------------------------
  // HOLD START
  // --------------------------
  function onHoldStart(evt) {
    if (state !== 'waitingForHold') return;

    try { rect.setPointerCapture(evt.pointerId); } catch(e){}

    activePointerId = evt.pointerId;
    pointerInside = true;
    initialPointerPos = { x: evt.clientX, y: evt.clientY };

    state = 'holding';
    setStatus('Waiting for green...');
    setMessage('');

    const delay = randomDelayMs();
    waitTimer = setTimeout(() => {
      if (state !== 'holding' || !pointerInside) return;

      // ------------------------------
      // SWITCH TO GREEN + LETTER
      // ------------------------------
      state = 'green';
      timeGreen = performance.now();

      requiredLetter = Math.random() < 0.5 ? 'A' : 'D';
      setRectState('green', requiredLetter);

      setStatus(`Green! Release AND press "${requiredLetter}"`);
      setMessage(`Press ${requiredLetter} and release the mouse.`);

      try { sound.currentTime = 0; sound.play().catch(()=>{}); } catch(e){}
    }, delay);
  }

  // --------------------------
  // POINTER MOVE CHECK
  // --------------------------
  function onPointerMove(evt) {
    if (!activePointerId || evt.pointerId !== activePointerId) return;
    if (state === 'idle' || state === 'showingResult') return;

    const box = rect.getBoundingClientRect();
    const inside =
      evt.clientX >= box.left && evt.clientX <= box.right &&
      evt.clientY >= box.top  && evt.clientY <= box.bottom;

    if (initialPointerPos &&
        Math.hypot(evt.clientX - initialPointerPos.x, evt.clientY - initialPointerPos.y) > MOVE_TOLERANCE) {
      handleEarlyRelease('Moved too much');
      return;
    }

    if (!inside && pointerInside) {
      pointerInside = false;
      handlePointerUp(evt, true);
    } else {
      pointerInside = inside;
    }
  }

  // --------------------------
  // EARLY RELEASE
  // --------------------------
  function handleEarlyRelease(reason) {
    clearTimeout(waitTimer);
    waitTimer = null;

    state = 'waitingForHold';
    setRectState('red','Hold');
    setStatus('Early release — try again');
    setMessage(`${reason}. Trial reset.`, '#b00020');

    try { rect.releasePointerCapture(activePointerId); } catch(e){}
    activePointerId = null;
    initialPointerPos = null;
    pointerInside = false;

    letterPressed = false;
    mouseReleased = false;
  }

  // --------------------------
  // POINTER UP
  // --------------------------
  function handlePointerUp(evt) {
    if (!activePointerId || evt.pointerId !== activePointerId) return;

    if (state === 'holding') {
      handleEarlyRelease('Released before green');
      return;
    }

    if (state === 'green') {
      mouseReleased = true;
      try { rect.releasePointerCapture(activePointerId); } catch(e){}
      activePointerId = null;
      checkFinishConditions();
      return;
    }
  }

  // --------------------------
  // FINISH CHECK
  // --------------------------
  function checkFinishConditions() {
    if (!letterPressed || !mouseReleased) return;

    const releasedAt = performance.now();
    const reaction = releasedAt - timeGreen;

    successfulTimes.push(reaction);
    trialIndex += 1;

    setMessage(`Good! Reaction: ${reaction.toFixed(0)} ms`, '#0a6d16');
    setStatus(`Recorded ${successfulTimes.length}/${TRIALS}`);

    state = 'showingResult';
    setRectState('disabled','Saved');

    setTimeout(nextTrial, 800);
  }

  // --------------------------
  // KEY HANDLING
  // --------------------------
  window.addEventListener('keydown', (e) => {
    if (state !== 'green') return;
    if (!requiredLetter) return;

    const pressed = e.key.toUpperCase();
    if (pressed === requiredLetter) {
      letterPressed = true;
      checkFinishConditions();
    }
  });

  // pointer cancel
  function onPointerCancel(evt) {
    if (!activePointerId || evt.pointerId !== activePointerId) return;

    if (state === 'holding') {
      handleEarlyRelease('Pointer cancelled');
    } else if (state === 'green') {
      mouseReleased = true;
      checkFinishConditions();
    } else {
      resetVars();
    }
  }

  // EVENT BINDINGS
  rect.addEventListener('pointerdown', (e)=>{
    if (e.button !== 0) return;
    onHoldStart(e);
  });

  rect.addEventListener('pointermove', onPointerMove);
  rect.addEventListener('pointerup',  handlePointerUp);
  rect.addEventListener('pointerleave', handlePointerUp);
  rect.addEventListener('pointercancel', onPointerCancel);

  startBtn.addEventListener('click', beginTest);

  restartBtn.addEventListener('click', () => {
    resetVars();
    trialIndex = 0;
    successfulTimes = [];
    resultsEl.style.display = 'none';
    setMessage('');
    setRectState('disabled','Start');
    startBtn.disabled = false;
    setStatus('Ready');
    updateTrialCounter();
  });

  rect.addEventListener('dragstart', e => e.preventDefault());

  // init
  setRectState('disabled','Start');
  setStatus('Ready');
  updateTrialCounter();
})();
</script>

</body>
</html>
